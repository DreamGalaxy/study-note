# MySQL

select展示时若展示不下，可以在结尾添加\G，会把每列转为1行来表示

## 1、DQL执行顺序

* 编写顺序

```mysql
SELECT				4
	字段列表
FROM				1
	表名列表
WHERE				2
	条件列表
GROUP BY			3
	分组字段列表
HAVING
	分组后续条件列表
ORDER BY			5
	排序字段列表
LIMIT				6
	分页参数
```



* 执行顺序

```mysql
FROM
	表名列表
WHERE
	条件列表
GROUP BY
	分组字段列表
HAVING
	分组后条件列表
SELECT
	字段列表
ORDER BY
	排序字段列表
LIMIT
	分页参数
```



## 2、UNION和UNION ALL

两个查询结果的列必须相同



UNION对两个结果集进行并集操作，不包括重复行，相当于distinct，同时进行默认规则的排序

UNION ALL对两个结果集进行并集操作，包括重复行，也不进行排序

在没有去重的前提下，使用UNION ALL的执行效率要比UNION高



## 3、事务

事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。



默认MySQL的事务是自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式地提交事务。



### 3.1、事务操作

* 查看/设置事务提交方式（全局）

```mysql
SELECT @@autocommit;
-- 0为手动提交，1为自动提交
SET @@autocommit=0;
```

* 开启事务（局部）

```mysql
START TRANSACTION 或 BEGIN;
```

* 提交事务

```sql
COMMIT;
```

* 回滚事务

```mysql
ROLLBACK;
```



### 3.2、事务的四大特性（ACID）

* 原子性（<font color="red">A</font>tomicity）：事务是不可分割的做小操作单元，要么全部成功，要么全部失败
* 一致性（<font color="red">C</font>onsistency）：事务完成时，必须使所有的数据都保持一致状态
* 隔离性（<font color="red">I</font>solation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行
* 持久性（<font color="red">D</font>urability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的 



### 3.3、并发事务问题

* 脏读：一个事务读到另外一个事务还没有提交的数据
* 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读
* 幻读：一个事务按条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了“幻影”



### 3.4、事务的隔离级别

| 隔离级别                     | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | :--: | :--------: | :--: |
| Read uncommitted             |  √   |     √      |  √   |
| Read committed（Oracle默认） |  ×   |     √      |  √   |
| Repeatable Read（MySQL默认） |  ×   |     ×      |  √   |
| Serializable                 |  ×   |     ×      |  ×   |



查看事务隔离级别

```mysql
SELECT @@TRANSACTION_ISOLATION;
```



设置事务隔离级别

```mysql
SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLED READ | SERIALIZABLE}
```



## 4、MYSQL体系结构

![image-20230829114316837](image\image-20230829114316837.png)

 

* 连接层

  最上层是一些客户端和链接服务，主要完成一些类似连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。

* 服务层

  第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。

* 引擎层

  存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。

* 存储层

  主要是将数据存储在文件系统之上，并完成与存储引擎的交互



### 4.1、存储引擎介绍

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎可以被称为表类型。



**MySQL默认存储引擎是InnoDB。**



创建表时，指定存储引擎：

```mysql
CREATE TABLE 表名(
	字段1 字段1类型 [COMMENT 字段1注释]
    ......
    字段n 字段n类型 [COMMENT 字段n注释]
)ENGINE=INNODB [COMMENT 表注释];
```



查询当前数据库支持的存储引擎

```mysql
show engines;
```



### 4.2、InnoDB

InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在MySQL5.5之后，InnoDB是默认的MySQL存储引擎。



特点：

* DML操作遵循ACID模型，支持事务

* 行级锁，提高并发访问性能

* 支持外键FOREIGN KEY约束，保证数据的完整性和正确性



文件：

​	xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。

​	参数：innodb_file_per_table



InnoDB的1个区（Extent）为1MB，包含64个页Page

1个Page为16KB

![image-20230829152312375](image\image-20230829152312375.png)



### 4.3、MyISAM

MyISAM是MySQL早期的默认存储引擎



特点：

* 不支持事务，不支持外键
* 支持表锁，不支持行锁
* 访问速度快



文件：

​	xxx.sdi：存储表结构信息

​	xxx.MYD：存储数据

​	xxx.MYI：存储索引



### 4.4、Memory

Memory引擎的表数据是存储在内存中的，由于受到硬件问题或断电问题的影响，只能将这些表作为临时表或缓存使用



特点：

* 内存存放
* hash索引（默认）



文件：

​	xxx.sdi：存储表结构信息



### 4.5、特点比较

|     特点     |       InnoDB        | MyISAM | Memory |
| :----------: | :-----------------: | :----: | :----: |
|   存储现在   |        64TB         |   有   |   有   |
|   事务安全   |        支持         |   -    |   -    |
|    锁机制    |        行锁         |  表锁  |  表锁  |
|  B+tree索引  |        支持         |  支持  |  支持  |
|   Hash索引   |          -          |   -    |  支持  |
|   全文索引   | 支持（5.6版本之后） |  支持  |   -    |
|   空间使用   |         高          |   低   |  N/A   |
|   内存使用   |         高          |   低   |  中等  |
| 批量插入速度 |         低          |   高   |   高   |
|   支持外键   |        支持         |   -    |   -    |



### 4.6、存储引擎选择

在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。

* InnoDB：**是MySQL的默认存储引擎**，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含了很多的更新、删除操作，那么InnoDB存储引擎是比较适合的选择
* MyISAM（不如MongoDB）：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的
* MEMORY（不如Redis）：将所有数据保存在内存中，访问速度快，通常用于临时表及存储。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保证数据的安全性



## 5、索引

**索引（index）**是帮助MySQL高效获取数据的**数据结构（有序）**。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引



**优点：**

* 提高数据检索的效率，降低数据库的IO成本
* 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗



**缺点：**

* 索引列会占用额外空间
* 索引大大提高了查询效率，但也降低了更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低



### 5.1、索引结构

二叉树缺点：顺序插入时，会形成一个链表，查询性能大大降低，大数据量的情况下，层级较深，检索速度慢

红黑树缺点：大数据量情况下，层级较深，检索速度慢



#### 5.1.1、B+Tree：

* 所有数据都会出现在叶子节点

* 叶子节点形成一个单向链表

* MySQL对经典的B+Tree进行了优化，在原B+Tree的基础上，增加了一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能



相对于B-Tree，B+Tree非叶子节点不存储数据，可以使每一页（Page）中存储更多的指针，从而使树的层高更低，搜索效率更高



相对Hash索引，B+Tree支持范围匹配及排序操作



InnoDB的指针占用6字节，主键如果为bigint，占用8字节

一页可以存储的索引节点数量 通过 n * 8 + (n + 1) * 6 = 16 * 1024（一页16k）可以算出约为1170，指针数量则为1171

b+树的高度为2时，则可以存储 1171 * (16k / 每行数据大小)，如果一行数据1k，则可以存储18736

b+树的高度为3时，则可以存储1171 * 1171 * (16k / 每行数据大小)，如果一行数据1k，则可以存储21,939,856





#### 5.1.2、Hash：

* 哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中

* 如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决

特点：

1. Hash索引只能用于对等比较（=，in），不支持范围查询（between，>，<，...）

2. 无法利用索引完成排序操作
3. 查询效率高，通常只需要一次检索就可以了（出现hash冲突时还需要在链表中比较），效率通常要高于B+tree索引



存储引擎支持：

在MySQL中，支持hash索引的是Memory引擎，而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的



### 5.2、索引分类

| 分类         | 含义                                                 | 特点                     | 关键字   |
| ------------ | ---------------------------------------------------- | ------------------------ | -------- |
| **主键索引** | 针对于表中主键创建的索引                             | 默认自动创建，只能有一个 | PRIMARY  |
| **唯一索引** | 避免同一个表中的某数据列中的值重复                   | 可以有多个               | UNIQUE   |
| **常规索引** | 快速定位特定数据                                     | 可以有多个               |          |
| **全文索引** | 全文索引查找的是文本中的关键词，而不是比较索引中的值 | 可以有多个               | FULLTEXT |



在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：

| 分类                               | 含义                                                       | 特点                 |
| ---------------------------------- | ---------------------------------------------------------- | -------------------- |
| 聚集/聚簇索引（Clustered Index）   | 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据 | 必须有，而且只有一个 |
| 非聚集/二级索引（Secondary Index） | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 | 可以存在多个         |



聚集索引选取规则：

* 如果存在主键，主键索引就是聚集索引
* 如果不存在主键，将使用的第一个唯一（UNQIUE）索引作为聚集索引
* 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引



回表查询：先根据二级索引查询到对应的主键值，然后根据主键值在聚集索引中查询到对应的行数据



### 5.3、索引语法

* 创建索引

  ```mysql
  CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_col_name,...);
  ```

* 查看索引

  ```mysql
  SHOW INDEX FROM table_name;
  ```

* 删除索引

  ```mysql
  DROP INDEX index_name ON table_name;



### 5.4、SQL性能分析

#### 5.4.1、SQL执行频率

 MySQL客户端连接成功后，通过show [session|global] status 命令可以提供服务器的状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问次数（7个下划线）

```mysql
SHOW GLOBAL STATUS LIKE 'Com_______';
```



#### 5.4.2、慢查询日志

慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志

MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：

```shell
# 开启MySQL慢日志查询开关
slow_query_log=1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time=2
```

配置后通过 `systemctl restart mysql` 重启mysql服务 

相关日志存储在/var/lib/mysql/localhost-slow.log中



#### 5.4.3、profile详情

show profiles能够在做SQL优化时帮助我们了解时间都耗费到哪里了。通过having_profiling参数，能够看到当前MySQL是否支持profile操作：

```mysql
SELECT @@have_profiling;
```

默认profiling是关闭的，可以通过set语句在session/global级别开启profiling：

```sql
SELECT profiling = 1;
```



查看profile详情

执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时：

```sql
# 查看每一条SQL的耗时基本情况
show profiles;

# 查看指定query_id的SQL语句各个阶段的耗时情况
show profile for query query_id;

# 查看指定query_id的SQL语句CPU的使用情况
show profile cpu for query query_id;
```



#### 5.4.4、explain执行计划

EXPLAIN或者DESC命令获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序。

语法：

```sql
# 直接在select语句之前加上关键词explain / desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;
```



Explain执行计划各字段的含义：

* id

  select查询的序列号，表示查询中执行select子句或者是操作表的顺序（id相同，执行顺序从上到下；id不同，值越大，越先执行）

* select_type

  表示SELECT的类型，常见的取值有SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等

* type

  表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all

  * NULL一般业务查询不会做到，当访问时不查询任何表如`SELECT 'A'`等直接给出查询结果的会是NULL
  * system相当于访问系统表
  * 根据主键或唯一索引访问一般会为const或eq_ref
  * 使用非唯一性的索引进行查询会为ref
  * index表示使用了索引，但对索引进行了遍历
  * all为全表扫描

* possible_key

  显示可能应用在这张表上的索引，一个或多个

* key

  实际使用的索引，如果为NULL，则没有使用索引

* key_len

  表示索引中使用的字节数，该字段为索引字段最大可能长度（索引有多个字段时，根据最左前缀选择的列及列的长度进行计算），并非实际使用长度，在不损失精确性的前提下，长度越短越好

* rows

  MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的

* filtered

  表示返回结果的行数占需读取行数的百分比，filtered的值越大越好

* extra

  其他未展示的值会在此展示



### 5.5、索引使用

#### 5.5.1、最左前缀法则

如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃了某一列，<font color="red">索引将部分失效（后面的字段索引失效）</font>



#### 5.5.2、范围查询

联合索引中，出现范围查询（>，<），<font color="red">范围查询右侧的索引列失效</font>

通过>=或<=可以规避这个问题，所以在业务允许的情况下，尽量使用>=和<=

```sql
# 不走索引
select * from tb_user where age < 20;
# 走索引
select * from tb_user where age <= 19;
```



#### 5.5.3、索引失效

* 索引列运算：不要在索引列上进行运算操作，<font color="red">索引将失效</font>

```sql
select * from tb_user where substring(phone, 10, 2) = '15';
```

* 字符串类型字段使用时，不加引号，<font color="red">索引将失效</font>

* 模糊查询：如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，<font color="red">索引将失效</font>

* or连接的条件：用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到；如果前后的列均有索引，则会使用到索引

* 数据分布影响：如果MySQL评估使用索引比全表更慢，则不使用索引，对于is null和is not null操作，也是根据该列中null的分布情况来决定是否使用索引
