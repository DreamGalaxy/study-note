nacos的权重算法巧妙利用了二分算法最后返回 应插入位置的特点：

代码入口NacosRule

nacos的负载算法其实是各实例权重都为1的权重负载。算法的核心：将权重按比例转化为一个长度为1的线段，比如service1权重0.2，service2权重为0.6，那么权重的array为[0.25,1]（线段比例和权重比例是相同的），然后产生一个0~1的随机数（ThreadLocalRandom.current().nextDouble(0.0D,1.0D)）,使用二分查找（Arrays.binarySearch()）找到这个随机数在权重array中的位置，Arrays.binarySearch()未找到时，会返回-(应插入的位置+1)，-(var+1)，因为小于零表示没找到，所以将返回值取反再-1就可以获得这个随机值应插入list的下标位置，也表示落在了权重线段的哪段（需要校验下有没越界并且随机值小于对应下标的），如果正常则返回该下标的实例，不正常则返回最后一个实例。



sentinel的fallback额外参数只能是Throwable.class，如果不填默认也是；而且要求其他参数、返回值和加注解的原方法一模一样。

入口在SentinelResourceAspect的invokrResourceWithSentinel在1.8.0的源码中，fallback在匹配对应的实现方法时，会去map中先找，没找到就通过反射从该类（当前使用@SentinelResource这个注解这个类）下找对应的fallback方法，返回值的比较可以为子类，但这里的参数比较是Arrays.equals分别和原方法的参数array以及原方法参数+Throwable的Array比较进行匹配，不能为子类，最后没找到则看是否有全局默认的fallback。
