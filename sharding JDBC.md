# 一、分库分表

## 1.1 为什么分库分表

以MySQL为例，单库数据量在5000万以内性能比较好，超过阈值后性能会随着数据量的增大而明显降低。单表的数据量超过1000w，性能也会下降严重。这就会导致一次查询所花的时间变长，并发操作达到一定量时可能会卡死，甚至会拖垮系统。除了提升硬件能力来提高数据处理能力，还可以把数据分散在不同数据库不同表中，使得单一数据库和表的数据量变小，从而达到提升数据库操作性能的目的，这就是分库分表。

分库分表就是把较大的数据库和数据表按照某种策略进行拆分，目的在于降低每个库每张表的数据量，减小数据库的负担，提高数据库的运行效率，缩短查询时间。另外，分库分表的改造是可控的，底层还是基于RDBMS，因此整个数据库的运维体系及相关基础设施都是可重用的。

## 1.2 分库分表的方式

### 1.2.1 垂直分表

例如用户在电商平台浏览商品时，首先看到的是商品的基本信息，如果对商品感兴趣时才会继续浏览该商品的详细描述。因此商品基本信息的访问频次要高于商品的详细信息。由于这两种数据的特性不一样，因此考虑将商品信息表拆分如下：

<img src="image\image-20220226151729072.png" alt="image-20220226151729072" style="zoom: 50%;" />

这种拆分就叫垂直分表。**垂直分表**定义：将一个表的字段分散到多个表中，每个表存储其中一部分字段。

**优点：**

1. 减少IO争抢，减少锁表的几率，查看不同表时互不影响
2. 充分发挥高频数据的操作效率，对商品概述数据操作的高效率不会被操作商品详情数据的低效率所拖累

一般来说，业务实体中的各个数据项访问的频次是不一样的，部分数据项可能是占用存储空间比较大的BLOB或是TEXT，所以当数据量很大时，可以将表**按字段拆分，将热门字段、冷门字段分开**放置在不同表中。垂直分表带来的性能提升，主要集中热门数据的操作效率上，而磁盘争用情况少。通常按照以下原则进行垂直拆分：

* 把不常用的字段单独放在一张表里
* 把TEXT，BLOB等大字段拆出来单独放在一张表里
* 经常组合查询的字段放在一张表里



### 1.2.2 垂直分库

通过垂直分表，数据库性能得到了一定程度的提升，但是还是没有达到要求，并且磁盘的空间也快不够了，因为数据始终放在一台服务器。库内垂直分表只解决了单一表数据量过大的问题，没有将表分布到不同的机器的库上，因此对于减轻数据库的压力来说，作用有限，大家还是竞争同一个物理机的CPU、内存、网络IO、磁盘。

<img src="image\image-20220226160030783.png" alt="image-20220226160030783" style="zoom: 67%;" />

由于商品信息与商品描述业务耦合度较高，因此一起被存放在PRODUCT_DB（商品库）；而店铺信息相对独立，因此被单独存放在STORE_DB（店铺库），这就叫垂直分库。

**垂直分库**是指按照业务进行分类，分布到不同数据库上面，每个库可以放在不同服务器上，从而达到多个服务器共同分摊压力的效果。

**优点：**

1. 解决业务层面的耦合，业务清晰
2. 能对不同业务的数据进行分级管理、维护、监控、扩展等
3. 高并发场景下，垂直分库可以在一定程度上提升IO、数据库连接数、单机硬件资源的性能



### 1.2.3 水平分库

当电商平台规模十分大的时候，店铺信息、商品信息都有成千上万条，从业务的角度讲已无法再进行垂直拆分。我们又想了一种办法，根据商品ID是奇数还是偶数，把商品信息分别存到两个数据库中，这就叫水平分库。

<img src="image\image-20220226162843396.png" alt="image-20220226162843396" style="zoom:67%;" />

**水平分库**是把同一个表的数据按照一定规则拆分到不同数据库中，每个库可以放在不同的服务器上。

**优点：**

1. 解决了单库大数据，高并发的性能瓶颈
2. 按照合理的拆分规则进行拆分，join操作基本避免跨库
3. 提高了系统的稳定性及可用性

当一个应用难以再细粒度的进行垂直拆分，或切分后数据量仍然巨大，存在单库读写、存储性能瓶颈，这时候就需要进行水平分库，经过水平切分的优化，往往能解决单库存储量及性能瓶颈。但由于同一个表被分配在不同的数据库，**需要额外进行数据操作的路由工作**，因此**大大增加了系统复杂度**。



### 1.2.4 水平分表

与水平分库思路类似，但水平分表拆分的是表

![image-20220226163044456](image\image-20220226163044456.png)

**水平分表**是在同一个数据库内，把同一表的数据拆分到多个表中

**优点：**

1. 避免单一表数据量过大而产生的性能问题
2. 避免IO争抢并减少锁表的几率

库内的水平分表解决了单一表数据量过大的问题，分出来的小表中只包含一部分数据，从而使得单张表的数据量变小，提高检索性能。但由于同一个表的数据被拆分为多张表，也**需要进行额外数据操作的路由工作**，因此**增加了系统的复杂度**。



### 1.2.5 总结：

一般来说，在系统设计阶段就应该根据业务耦合松紧来确定垂直分库、垂直分表的方案，在数据量及访问压力不是特别大的情况下，首先考虑缓存、读写分离、索引技术等方案，若数据量极大且持续增长，再考虑水平分库分表方案。



## 1.3 分库分表带来的问题

### 1.3.1 事务一致性问题

由于分库分表把数据分布在不同库甚至不同服务器，不可避免会带来分布式事务问题，需要额外编程解决该问题。

### 1.3.2 跨节点join

分库分表后数据不在同一个库或同一个表中，甚至不在同一台服务器上，无法通过sql进行关联查询，需要额外编程解决该问题。

### 1.3.3 跨节点分页、排序和聚合函数

跨节点多库进行查询时，limit分页，order排序以及聚合函数等问题，就变得非常复杂了。需要先在不同分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序。

### 1.3.4 主键避免重复

在分库分表环境中，由于表中数据同时存在不同数据库中，主键值平时使用的自增长将无用武之地，某个分区数据库生成的ID无法保证全局唯一。因此需要单独设计全局主键，以避免跨库主键重复问题。

### 1.3.5 公共表

实际应用场景中，参数表、数据字典表等都是数据量较小，变动少，而且属于高频联合查询的依赖表。

可以将这类表在在每个数据库中都保存一份，所有对公共表的更新操作都同时发到所有分库执行。

# 二、Sharding-JDBC

## 2.1 概述

Sharding-JDBC是当当网研发的开源分布式数据库中间件，从3.0版本开始改名为Sharding-Sphere，4.0后为Apache版本

Sharding-Sphere是一套开源的分布式数据库中间件解决方案组成的生态圈，又Sharding-JDBC、Sharding-Proxy和Sharding-SideCar三款产品组成

Sharing-JDBC定位为轻量级Java框架，在JDBC层提供额外服务。他使用客户端直连数据库，以jar的形式提供服务，无需额外部署和依赖，可以理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。

* 适用于任何基于Java的ORM框架，如：JPA，Hibernate，Mybatis，Spring JDBC Template或直接使用JDBC
* 适用于任何第三方的数据库连接池，如：DBCP，C3P0，Druid，HikariCP
* 适用于任何支持JDBC规范的数据库，如：MySQL，Oracle，SQL Server和Postgre SQL

## 2.2 功能介绍

核心功能是 **数据分片** 和 **读写分离**

### 2.2.1 数据分片

数据分片是Sharding-JDBC的核心功能，它是按照某个维度将存放在单一数据库中的数据分散存放到多个数据表或库中，以达到提升性能瓶颈和可用性的效果。数据分片的有效手段是对关系型数据库进行分库分表。

### 2.2.2 读写分离

数据库的写操作比较耗时，而读操作相对较快，在高并发的情况下，写操作会严重拖累读操作，这是单纯分库分表无法解决的。

可以将数据库拆分为主库和从库，**主库只负责增删改**操作，**从库只负责查询**操作，这就是读写分离。它能够有效避免有数据更新导致的行锁，使得整个系统的查询性能得到极大的改善。

还能搞一主多从，这样就可以将查询请求均匀地分散到多个从库，能够进一步地提升系统的处理能力。使用多主多从的方式不但能提升系统的吞吐量，还能够提升系统的可用性，可以达到在任意一个数据库宕机甚至磁盘损坏的情况下仍不影响系统的正常运行。

读写分离的数据节点中的数据内容是一致的，所以在采用读写分离时，要解决**主从数据同步的问题**。

Sharding-JDBC读写分离则是**根据SQL语义的分析，将读操作和写操作分别路由至主库和从库**。它提供透明化读写分离，让使用方尽量像使用一个数据库一样进行读写分离操作。**Sharing-JDBC不提供主从数据同步功能**，需要采用其他机制支持。



### 2.3 流程分析

Sharding-JDBC在拿到sql后做了什么：

1. 解析sql，获取分片键
2. 通过配置文件的配置的规则，知道分片键为何值时操作哪张表，例如分片键为`order_id`：`t_order_$->{order_id % 2 + 1}`，当`order_id`为偶数是操作`t_order_1`，为奇数时操作`t_order_2`
3. Sharding-JDBC根据order_id的值改写sql，改写后的sql为真实执行的sql
4. 执行改写后的sql
5. 将所有真正执行的结果进行汇总，返回



## 3.执行原理

### 3.1 基础概念

#### 3.1.1 逻辑表

水平拆分的数据库（表）的相同逻辑和数据结构表的总称。例：订单数据根据主键尾数拆分为10张表，分别是`t_order_0`到`t_order_9`，它们的逻辑表名为`t_order`

#### 3.1.2 真实表

在分片的数据库中真实存在的物理表，即上述示例的`t_order_0`到`t_order_9`

#### 3.1.3 数据节点

数据分片的最小单元。由数据源名称和数据表组成，例：`ds_0.t_order_0`

#### 3.1.4 分片键

用于的分片数据库字段，是将数据库（表）水平拆分的关键字段。例：将订单表中的订单主键的尾数取模分片，则订单主键为分片字段。SQL中如果无分片字段，将执行全路由，性能较差。除了对单分片字段的支持，Sharding-Sphere也支持根据多个字段进行分片。

#### 3.1.5 分片算法

通过分片算法将数据分片，支持通过`=`、`BETWEEN`和`IN`分片。分片算法需要应用方开发者自行实现，可实现的灵活度非常高。包括：精确分片算法、范围分片算法、复合分片算法 等。例如：`where order_id = ?`将采用精确分片算法，`where order_id in (?,?,?)`将采用精确分片算法，`where order_id BETWEEN ? and ?`将采用范围分片算法，复合分片算法用于分片键有多个的复杂情况。

#### 3.1.6 分片策略

包含分片键和分片算法，用于分片算法的独立性，将其独立抽离。真正可用于分片操作的是分片键+分片算法，也就是分片策略。内置的分片策略大致可分为：尾数取模、哈希、范围、标签、时间 等。由用户配置的分片策略则更加灵活，常用的方式是用行表达式配置分片策略，它采用Groovy表达式表示，如：`t_user_$->{u_id % 8}`表示根据`u_id`模8而分成8张表，表名称为`t_user_0`到`t_user_7`。

#### 3.1.7 自增主键生成策略

通过在客户端生成自增主键替换以数据库原生自增主键的方式，做到分布式全局主键无重复

#### 3.1.8 绑定表

指分片规则一致的主表和子表。如：商品信息表 和 商品描述表，均按照 `商品id` 分片，则这两张表互为绑定关系表。绑定表间的多表关联查询不会出现笛卡尔积，关联查询效率会大大提升。

* 例：商品信息和商品描述使用商品id分片且绑定，则inner join之会查询2条

  `商品信息1 inner join 商品描述1 on 商品id`

  `商品信息2 inner join 商品描述2 on 商品id`

* 否则会查询笛卡尔积（例子为4条）

  `商品信息1 inner join 商品描述1 on 商品id`

  `商品信息1 inner join 商品描述2 on 商品id`

  `商品信息2 inner join 商品描述1 on 商品id`

  `商品信息2 inner join 商品描述2 on 商品id`

注意：绑定表之间的分片键要完全相同

#### 3.1.9 广播表

指所有的分片数据源中都存在的表，表结构和表中的数据在每个数据库中完全一致，适用于数据量不大且需要与海量数据的表进行关联查询的场景，例如字典表

### 3.2 SQL解析

当Sharding-JDBC接收到一条SQL时，会陆续执行`SQL解析 => 查询优化 => SQL路由 => SQL改写 => SQL执行 => 结果归并`，最终返回执行结果。

SQL解析过程分为**词法解析**和**语法解析**。词法解析器用于将SQL拆解为不可再分割的原子符号，称为Token，再根据不同数据库方言提供的字典，将其归类为关键字，表达式，字面量和操作符。再使用语法解析器将SQL转为抽象语法树。

例如以下SQL：

```sql
SELECT id, name FROM t_user WHERE status = 'ACTIVE' AND age > 18
```

解析后的语法树如下图（关键字用绿色表示，变量用红色表示，灰色表示需要进一步拆分）：

<img src="image\image-20220227153330805.png" alt="image-20220227153330805" style="zoom:67%;" />

最后通过对抽象语法树的遍历去提炼分片所需要的**上下文**，并标记有可能需要**SQL改写**的位置。供分片使用的解析上下文包含查询选择项（Select Item）、表信息（Table）、分片条件（Sharding Condition）、自增主键信息（Auto Increment Primary Key）、排序信息（Order By）、分组信息（Group By）及分页信息（Limit、Rownum、Top）。



### 3.3 SQL路由

​	SQL路由就是把**针对逻辑表**的数据操作映射到对应数据结点的过程

​	根据解析上下文匹配数据库和表的分片策略，并生成路由路径。对于携带分片键的SQL，根据<font color='blue'>**分片键操作符不同**</font>可以划分为<font color='blue'>**单片路由**（分片键的操作符是等号）、**多片路由**（分片键的操作符是IN）和**范围路由**（分片键的操作符是BETWEEN）</font>，不携带分片键的SQL则采用广播路由。根据<font color='green'>**分片键**</font>进行路由的场景可分为<font color='green'>**直接路由**、**标准路由**、**笛卡尔路**</font>由等。

#### 3.3.1 标准路由

标准路由是Sharding-JDBC最推荐的使用方式，它的适用范围是不包含关联查询或仅包含绑定表之间的关联查询的SQL，当分片运算符是`=`时，路由结果将落入单库（表），当分片运算符是`BETWEEN`或`IN`时，则路由结果不一定落入唯一的库（表），因此一条逻辑SQL最终可能被拆分为多条用于执行的真实SQL。

例如：如果按照`order_id`的奇偶进行数据分片，一个单表查询的SQL如下：

```sql
SELECT * FROM t_order WHERE order_id IN (1, 2);
```

那么路由的结果应为：

```sql
SELECT * FROM t_order_0 WHERE order_id IN (1, 2);
SELECT * FROM t_order_1 WHERE order_id IN (1, 2);
```



绑定表的关联查询与单表查询复杂度和性能相当，例如一个包含绑定表的关联查询SQL如下：

```sql
SELECT * FROM t_order o INNER JOIN t_order_item i ON o.order_id = i.order_id WHERE order_id IN (1, 2);
```

那么路由的结果为：

```sql
SELECT * FROM t_order_0 o INNER JOIN t_order_item_0 i ON o.order_id = i.order_id WHERE order_id IN (1, 2);
SELECT * FROM t_order_1 o INNER JOIN t_order_item_1 i ON o.order_id = i.order_id WHERE order_id IN (1, 2);
```

SQL拆分的数目与单表是一致的。



#### 3.3.2 笛卡尔路由

笛卡尔路由是最复杂的情况，他无法根据**绑定表**的关系定位分片规则，因此非绑定表之间的关联查询需要拆解为笛卡尔积组合执行。如果上述例子中SQL未配置绑定表关系，那么路由的结果为：

```sql
SELECT * FROM t_order_0 o INNER JOIN t_order_item_0 i ON o.order_id = i.order_id WHERE order_id IN (1, 2);
SELECT * FROM t_order_0 o INNER JOIN t_order_item_1 i ON o.order_id = i.order_id WHERE order_id IN (1, 2);
SELECT * FROM t_order_1 o INNER JOIN t_order_item_0 i ON o.order_id = i.order_id WHERE order_id IN (1, 2);
SELECT * FROM t_order_1 o INNER JOIN t_order_item_1 i ON o.order_id = i.order_id WHERE order_id IN (1, 2);
```

<font color='red'>笛卡尔积路由查询性能较低</font>，需谨慎使用



#### 3.3.3 全库路由表

对于不携带分片键的SQL，则采用广播路由的方式。根据SQL类型又可划分为**全库表路由**、**全库路由**、**全实例路由**、**单播路由**和**阻断路由**这5种类型。其中全库表路由用于处理对数据库中与其逻辑表相关的所有真实表的操作，主要包括不带分片键的DQL（数据查询）和DML（数据操纵），以及DDL（数据定义）等。例如：

```sql
SELECT * FROM t_order WHERE good_prority IN (1, 10);
```

因为分片键是`order_id`，SQL中没有，则会遍历所有数据库中的所有表，逐一匹配逻辑表和真实表名，能够匹配上的则执行，路由的结果为：

```sql
SELECT * FROM t_order_0 WHERE good_prority IN (1, 10);
SELECT * FROM t_order_1 WHERE good_prority IN (1, 10);
SELECT * FROM t_order_2 WHERE good_prority IN (1, 10);
SELECT * FROM t_order_3 WHERE good_prority IN (1, 10);
```



### 3.4 SQL改写

面向逻辑表编写的SQL并不能真实地在数据库中执行，SQL改写用于将逻辑SQL改写为在真实数据库中可以执行的SQL。

例如：

```sql
SELECT order_id FROM t_order WHERE order_id = 1;
```

假设该SQL配置分片键order_id，并且order_id = 1的情况将路由至真实表1，则改写后的SQL为：

```sql
SELECT order_id_1 FROM t_order WHERE order_id = 1;
```



再比如Sharding-JDBC需要在结果归并时获取相应数据，但该数据未能通过查询的SQL返回。这种情况主要是针对`GROUP_BY`和`ORDER BY`。结果归并时，需要根据`GROUP_BY`和`ORDER BY`的字段项进行分组和排序，但如果原始SQL的选项中没有包含分组项或排序项，则需要对原始SQL进行改写，例如：

```sql
SELECT order_id, user_id FROM t_order ORDER BY user_id;
```

由于使用user_id进行排序，在结果归并中需要能够获取到`user_id`的数据，上述SQL可以获取到`user_id`，因此无需补列。

但如果选择项中不包含结果归并时所需的列，则需要进行补列，如：

```sql
 SELECT order_id FROM t_order ORDER BY user_id;
```

由于原始SQL中不包含需要在结果归并时需要的`user_id`，因此需要对SQL进行补列改写，补列后的SQL是

```sql
SELECT order_id, user_id AS ORDER_BY_DERIVED_0 FROM t_order ORDER BY user_id;
```



### 3.5 SQL执行

​		Sharding-JDBC采用一套自动化的执行引擎，负责将路由和改写完的真实SQL安全且高效地发送到底层数据源进行执行。它不是简单地将SQL通过JDBC直接发送至数据源执行；也不是直接将执行请求放入线程池去并发执行。它更关注平衡数据源连接创建以及内存占用所产生的消耗，以及最大限度地合理利用并发等。执行引擎的目标是自动化地平衡资源控制与执行效率，它能在以下两种模式下自适应切换：

#### 内存限制模式

​		使用此模式的前提是，Sharding-JDBC对一次操作所耗费的数据库连接数量不做限制。如果实际执行的SQL需要对某数据库实例中的200张表进行操作，则对每张表创建一个新的数据库连接，并通过多线程的方式并发处理，以达成执行效率最大化。

#### 连接限制模式

使用此模式的前提是，Sharding-JDBC严格控制对一次操作所耗费的数据库连接数量。如果实际执行的SQL需要对某数据库实例中的200张表进行操作，那么只会创建唯一的数据库连接，并对200张表串行处理。如果一次操作中的分片散落在不同数据库，仍采用多线程处理不同数据库的操作，但每个库的每次操作仍然只创建一个唯一的数据库连接。



内存限制模式适用于OLAP（On-Line Analytical Processing，主要是对数据的查询）操作，可以通过放宽对数据库连接的限制提升系统吞吐量连接限制模式适用于OLTP（On-Line Transaction Processing主要是对数据的增删改）操作，OLTP通常带有分片键，会路由到单一分片，因此严格控制数据库连接，以保证在线系统数据库资源能够被更多的应用所使用，是明智的选择。



### 3.6 结果归并

​		将从各个数据节点获取的多数据结果集，组合成为一个结果集并正确的返回至请求客户端，称为结果归并。

​		Sharding-JDBC支持的结果归并从功能上可分为**遍历**、**排序**、**分组**、**分页**和**聚合**5种类型，他们是组合而非互斥的关系。

归并引擎的整体结构划分如下图：

<img src="image\image-20220227201221105.png" alt="image-20220227201221105" style="zoom: 50%;" />

​		结果归并从结构可以分为**流式归并**、**内存归并**和**装饰者归并**。流式归并和内存归并是互斥的，装饰者归并可以在流式归并和内存归并之上做进一步处理

​		**内存归并**：将所有分片结果集的数据都遍历存储在内存中，再通过统一的分组、排序以及聚合等计算后，再将其封装成逐条访问的数据结果集返回。

​		**流式归并**：是指每一次从数据库结果集中获取到的数据，都能够通过游标逐条获取的方式返回正确的单条数据，它与数据库原生的返回结果集的方式最为契合。（边获取边处理）

​		下边举例说明排序归并的过程，如下图是一个通过分数进行排序的示例图，它采用流式归并方式。图中展示了3张表返回的数据结果集，每个数据结果集已经根据分数排序完毕，但是3个数据结果集之间是无序的。将3个数据结果集的当前游标指向的数据值进行排序，并放入优先级队列，t_score_0的第一个数据值最大，t_score_2的第一个数据值次之，t_score_1的第一个数据值最小，因此优先级队列根据t_score_0 , t_score_2和t_score_1的方式排序队列。

<img src="image\image-20220227204824107.png" alt="image-20220227204824107" style="zoom:50%;" />

<img src="image\image-20220227205116926.png" alt="image-20220227205116926" style="zoom:50%;" />

​		**装饰者归并**：是对所有的结果集归并进行统一的功能增强，比如归并时需要聚合SUM前，在进行聚合计算前，都会通过内存归并或流式归并查询出结果集。因此，聚合归并是在之前介绍的归并类型之上追加的归并能力，即装饰者归并。



## 4. 分库分表配置

[官方配置参考链接](https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/spring-boot-starter/rules/sharding/)

```properties
# 分库策略，将一张逻辑表映射到多个数据源
spring.shardingsphere.rules.sharding.tables.<逻辑表名称>.database-strategy.<分片策略>.<分片策略属性名>=#分片策略属性值

# 分表策略，将一张逻辑表映射到多个实际表
spring.shardingsphere.rules.sharding.tables.<逻辑表名称>.table-strategy.<分片策略>.<分片策略属性名>=#分片策略属性值
```

### 分片策略

Sharding-JDBC支持以下几种分片策略，但以下的分片策略只能选其一

* **standard**：标准分片策略，对应`StandardShardingStrategy`。提供对SQL语句中的`=`，`IN`和`BETWEEN AND`的分片操作支持。`StandardShardingStrategy`**只支持单分片键**，提供`PreciseShardingAlgorithm`和`RangeShardingAlgorithm`两个分片算法。`PreciseShardingAlgorithm`是必选的，用于处理`=`和`IN`的分片。`RangeShardingAlgorithm`是可选的，用于处理`BETWEEN AND`分片，如果不配置`RangeShardingAlgorithm`，SQL中的`BETWEEN AND`将按全库路由处理。

* **complex**：复合分片策略，对应`ComplexShardingStrategy`。提供对SQL中的`=`，`IN`和`BETWEEN AND`的分片操作支持。`ComplexShardingStrategy`**支持多分片键**，由于多分片键之间的关系复杂，因此未进行过多的封装，而是直接将分片键值组合以及分片操作符传至分片算法，完全由应用开发者实现，提供最大的灵活度。
* **inline**：行表达式分片策略，对应`InlineShardingStrategy`。使用Groovy的表达式，提供对SQL中的`=`，`IN`和`BETWEEN AND`的分片操作支持，**只支持单分片键**。对于简单的分片算法，可以通过简单的配置使用，从而避免繁琐的Java代码开发，如`t_user_$->{u_id % 8}`表示`t_user`根据`u_id`模8，而分成8张表，表名称为`t_user_0`到`t_user_7`。
* **hint**：Hint分片策略，对应`HintShardingStrategy`。通过Hint而非SQL解析的方式进行分片。对于分片字段非SQL决定，而由其他外置条件决定的场景，可使用SQL Hint灵活的注入分片字段。例：内部系统，按照员工登陆主键分库，而数据库中并无此字段。SQL Hint支持通过Java API和SQL注释（待实现）两种方式使用。
* **none**：不分片策略，对应`NoneShardingStrategy`。不分片的策略。

