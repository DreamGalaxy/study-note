# JVM



## jvm打印gc日志是否会影响jvm性能？



jstat命令：

jstat查询的数据都是JVM性能计数器中存储的内容（[Performance Counters](http://openjdk.java.net/groups/hotspot/docs/Serviceability.html#bjvmstat)），jstat读取通过mmap内存映射读取数据，在/tmp/hsperfdata_username/vmid中



jvm打印日志：

日志会阻塞gc：https://blog.csdn.net/q66562636/article/details/125339109

磁盘的I/O、日志的详细程度均会影响日志打印速度



jdk9中更新了日志打印的框架，有了日志级别，且支持滚动更新

jdk17中更新了异步日志参数-Xlog:async





## GraalVM

### Complier与Interpreter

编译：将源代码编译为机器码

编译型语言需要编译器，一次编译后即可执行

解释型语言需要解释器，逐行解释执行

Java是半编译半解释，JVM既有解释器又有编译器（JIT：即时编译）

|              | 编译器                                             | 解释器                                                   |
| ------------ | -------------------------------------------------- | -------------------------------------------------------- |
| 机器执行速度 | 快，因为源代码只需被转换一次                       | 慢，因为每行代码都需要被解释执行                         |
| 开发效率     | 慢，因为需要耗费大量时间编译                       | 快，无需花费时间生成目标代码，更快地开发和测试           |
| 调试         | 难以调试编译器生成的目标代码                       | 容易调试源代码，因为解释器一行一行地执行                 |
| 可移植性     | 不同平台需要重新编译目标平台代码                   | 同一份源码可以跨平台执行，因为每个平台会开发对应的解释器 |
| 学习难度     | 相对较高，需要了解源代码、编译器以及目标机器的知识 | 相对较低，无需了解机器的细节                             |
| 错误检查     | 编译器可以在编译代码是检查错误                     | 解释器只能在执行代码时检查错误                           |
| 运行时增强   | 无                                                 | 可以动态增强                                             |



### AOT与JIT

AOT：Ahead-of-Time（提前编译）：程序执行前，全部被编译成机器码

JIT：Just in Time（即时编译）：程序边编译边运行



java

|      | JIT                                                          | AOT                                                          |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 优点 | 1.具备实时调整能力<br>2.生成最优机器指令<br>3.根据代码运行情况优化内存占用 | 1.速度快，优化了运行时编译时间和内存消耗<br>2.程序初期就能达到最高性能<br>3.加快程序启动速度 |
| 缺点 | 1.运行期边编译速度慢<br>2.初始编译不能达到最高性能           | 1.程序第一次编译占用时间长<br>2.牺牲高级语言的一些特性       |



### JVM编译器

JVM中集成了两种编译器，Client Compiler和Server Compiler；

* Client Compiler注重启动速度和局部的优化
* Server Compiler更加关注全局优化，性能更好，但由于会进行更多的全局分析，所以启动速度会慢



Client Compiler：

* HotSpot VM带有一个Client Compiler **C1编译器**
* 这种编译器启动速度快，但是性能比Server Compiler要差一些
* C1编译后的机器码执行效率没有C2的高



Server Compiler：

* Hotspot虚拟机中使用的Server Compiler有两种：**C2**和**Graal**
* 在Hotspot VM中，默认的Server Compiler是**C2编译器**



### 分层编译

Java 7开始引入了分层编译（Tiered Compiler）的概念，它结合了C1和C2的优势，追求启动速度和峰值性能的一个平衡。分层编译将JVM的执行状态分为了五个层次。五个层级分别是：

* 解释执行
* 执行不带profiling的C1代码
* 执行仅带方法调用次数以及循环回边执行次数profiling的C1代码
* 执行所有带profiling的C1代码
* 执行C2代码

profiling就是手机能够反映程序执行状态的数据，其中最基本的统计数据就是方法的调用次数，以及循环回变的执行测试

循环和回边：

* 循环则是指在程序中反复执行某个代码块的过程

* 回边指的是程序执行到某个点后,再次回到该点继续执行的过程,也称为跳转



<img src="image\image-20230824172114099.png" alt="image-20230824172114099" style="zoom:50%;" />

* 图中第①条路径，代表编译的一般情况，热点方法从解释器执行到被3层的C1编译，最后被4层的C2编译。
* 如果方法比较小（比如Java服务中常见的getter/setter方法），3层的profiling没有收集到有价值的数据，JVM就会断定该方法对于C1代码和C2代码的执行效率相同，就会执行图中第②条路径。在这种情况下，JVM会在3层编译后，放弃进入C2编译，直接选择用1层的C1编译运行。
* 在C1忙碌的情况下，执行图中第③条路径，在解释执行过程中对程序进行profiling，根据信息直接由第4层的C2编译
* 前文提到C1中的执行效率是 1层 > 2层 > 3层，第3层一般要比第2层慢35%以上，所以在C2忙碌的情况下，执行图中第④条路径。这时方法会被2层的C1编译，然后再被3层的C1编译，一减少方法在3层的执行时间。
* 如果编译器做了一些比较激进的优化，比如分支预测，在实际运行时发现预测出错，这时就会进行反优化，重新进入解释执行，图中第⑤条执行路径代表的就是反优化。

总的来说，C1的编译速度更快，C2的编译质量更高，分层编译的不同编译路径，也就是JVM根据当前服务的运行情况来寻找当前服务的最佳平衡点的一个过程。从JDK8开始，JVM默认开启分层编译。



### java与云原生

存在的问题：

* java应用如果用jar，启动后都是解释执行，热点代码才能编译成机器码；初始启动速度慢，初始处理请求数量少
* 大型云平台要求每一种应用都必须秒级启动，每个应用都要求效率更高

期望的效果：

* java应用也能提前被编译成机器码，随时急速启动，一启动就急速运行，最高性能
* 编译成机器码的好处：
  * 另外的服务器还需要安装java环境
  * 编译成机器码的，可以在这个平台（linux、window）直接运行



### GraalVM

GraalVM是一个高性能的JDK，旨在加速用java和其他JVM语言编写的应用程序的执行，同时还提供JavaScript、Python和许多其他流行语言的运行时。

GraalVm提供了**两种**运行Java应用程序的方法：

1. 在HotSpot上使用Graal即时（JIT）编译器
2. 作为预先编译（AOT）的本机可执行文件运行

GraalVM的多语言能力使得在单个应用程序中混合多种编程语言称为可能，同时消除了外部语言调用的成本。



并不是所有的Java代码都能支持本地打包，但springboot3保证了spring的所有应用程序都能在AOT的时候提前告知graalvm，其他框架需要看各自的支持情况

- 动态能力损失：例如反射的代码（动态获取构造器，反射创建对象，反射调用一些方法）

  解决方案：需要进行一些额外的处理（springboot的注解）：提前告知graalvm反射会用到哪些方法、构造器

* 配置文件损失：

  解决方案：额外处理（配置中心）：提前告知graalvm配置文件怎么处理

* 二进制里面不能包含的，不能动态的都需要提前处理



命令：

```shell
# 从入口开始，编译整个jar
native-image -cp boot3-15-aot-common-1.0-SNAPSHOT.jar 主类包名类名 -o 生成可执行文件的名字

# 编译某个类【必须有main入口，否则无法编译】
native-image -cp .\classes 主类包名类名
```

