# 操作系统中上下文切换和内核切换的关系

**结论**：二者没有直接的关系，但进程切换以及线程切换需要在内核态完成，此时也需要进行上下文的切换。



线程是调度的基本单位，而进程则是资源分配的基本单位。



CPU的上下文切换分为几种场景：进程上下文切换、线程上下文切换、中断上下文切换



* 进程上下文切换一定要在内核态中进行，如果进程当前为用户态就需要先先保存程序计数器、寄存器、虚拟内存等进程用户态的资源，再切换为内核态，执行完内核任务后还需要切换回用户态，并恢复资源。

* 线程上下文切换只需要保存程序计数器、寄存器，以及线程私有的变量，而虚拟内存是同一进程内线程共享的资源，不需要保存。

* 中断是为了快速响应硬件的事件，中断要先将当前进程的状态保存下来，这样中断结束后进程仍然可以从原来的状态恢复运行，中断上下文的切换并不涉及进程的用户态，所以当中断程序打断了正在处于用户态的进程，不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源，只需要保存和恢复这个进程的内核态中的资源包括CPU寄存器、内核堆栈等。对于同一个CPU来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生，一般来说中断程序都执行比较快短小精悍，以便快速结束执行之前的任务。当中断上下文切换次数比较多的时候，会耗费大量的CPU



linux中线程又分为用户线程、内核线程和混合线程：

* 用户线程对操作系统是不可见的，此时线程间的线程切换在用户态即可完成，所以不需要进行上下文转换；但是一个线程阻塞会导致进程内所有的用户线程阻塞，并且只会有一个cpu调度线程。
* 内核线程对操作系统可见，可由多个cpu调度，但内核线程切换需要切换到内核态，则需要进行上下文的切换



## 为什么分内核态和用户态

假设没有这种内核态和用户态之分，程序随便就能访问硬件资源，比如说分配内存，程序能随意的读写所有的内存空间，如果程序员一不小心将不适当的内容写到了不该写的地方，就很可能导致系统崩溃。

用户程序进行系统调用后，操作系统执行一系列的检查验证，确保这次调用是安全的，再进行相应的资源访问操作。内核态能有效保护硬件资源的安全。



## 系统调用

从用户态到内核态的转变，需要通过系统调用来完成。比如，当我们查看文件内容时，就需要多次系统调用来完成：首先调用 open() 打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件。

系统调用会将CPU从用户态切换到核心态，以便 CPU 访问受到保护的内核内存。

系统调用的过程会发生 CPU 上下文的切换，CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。

而系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。

注意：系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。

系统调用过程通常称为特权模式切换，而不是进程上下文切换。



## 进程上下文切换

进程上下文切换跟系统调用又有什么区别呢？

首先，进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。

因此，进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、用户栈等保存下来；而加载下一个进程的内核态后，还需要加载这个进程的虚拟内存和用户栈。



## 进程的上下文切换的时机

进程在被调度的时候需要切换上下文，可能是主动地，也有可能是被动的

- 系统进程正常调度算法导致进程上下文切换，例如目前使用的时间片轮转算法，当一个进程的时间片耗尽之后，CPU会进项进程的调度切换到其他进程
- 进程在资源不足的时候，会被挂起例如在等待IO或者内存不足的时候，会主动挂起，并且等待系统调度其他进程
- 当进程通过一些睡眠函数sleep()主动挂起的时候，也会重新调度
- 当有高优先级的进程运行时，当前进程也会被挂起
- 当发生硬件中断时，CPU上的进程会被中断挂起

